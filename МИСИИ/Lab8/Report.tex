\documentclass[a4paper,14pt]{extarticle}
\usepackage{../../tex-shared/report-layout}

\renewcommand{\mylabnumber}{8}
\renewcommand{\mylabtitle}{Разработка и исследование экспертной системы}
\renewcommand{\mysubject}{Методы и средства искусственного интеллекта}
\renewcommand{\mylecturer}{Забаштанский А.К.}

\begin{document}
\input{../../tex-shared/title-page.tex}

\section{Цель работы}
Разработка экспертной системы продукционного типа на Прологе, исследование
базовых принципов организации экспертных систем.

\section{Задание на работу}
Реализовать продукционную экспертную систему в соответствии с номером варианта.
При этом количество рассматриваемых объектов предметной области должно быть не
менее 10 и характеризующих их атрибутов также — не менее 10. Система должна
уметь давать объяснения вывода.

\textbf{Предметная область – микропроцессоры.}

\section{Ход работы}
\subsection{Разработка программы}
Текст разработанной программы:
\begin{lstlisting}
% База знаний ЭС классификация микропроцессоров.
% База знаний, необходимая для опредения структуры микропроцессоров
% Имеем множество различных структур микропроцессоров

%Интерпретатор классифицирующей ЭС  
% Интерпретатор (машина вывода) для ЭС продукционного типа
% Метод вывода: обратный вывод
% Вариант 2: интерпретатор обрабатывает правила, в которых
% предпосылки задаются в виде списка условий.
% Это позволяет в условной части правила, задавать произвольное 
% количество условий.
:-dynamic
сообщено/2.

определить_операторы:-
	op(950, xfx, то),
	op(960, fx, если),
	op(970, xfx, '::').
:-определить_операторы.

%============обратный вывод======================================================
% реализуется предикатом найти(S,Стек,Д),где S - список проверяемых гипотез,
% Стек - стек из имен доказываемых гипотез и правил (используется при ответе на 
% вопросы "почему), Д - дерево вывода целевого утверждения (используется при отве-
% те на вопросы "как"). Предикат получает на вход список [Н] и Стек=[H] и в про-
% цессе обратного вывода строит дерево вывода Д.
% Предикат "найти" для доказательства отдельных гипотез из списка S
% использует предикат найти1(Н,Стек,Дерево).
%--------------------------------------------------------------------------------
%
% случай1:если цель Н была подтверждена пользователем,
% то дерево вывода Д=сообщено(Н).
найти1(H,Стек,сообщено(H)):-сообщено(H,да).
найти1(H,Стек,сообщено(H)):-запрашиваемая(H),
							not(сообщено(H,_)),спроси(H,Стек).
							
% случай2:если цель Н подтверждается фактом, уже известным системе,
% то дерево вывода Д=Факт :: H
найти1(H,Стек,Факт :: H):-Факт :: H.

% случай3: если цель Н соответствует следствию одного из 
% правил -> Правило :: если H1 то H
% и если Д1 дерево вывода для подцели Н1,
% то Д= Правило :: если Д1 то H и добавить № правила в Стек
найти1(H,Стек,Правило :: если Д1 то H):-
					Правило :: если H1 то H,
					найти(H1,[Правило | Стек],Д1).
	
% случай4: если доказывается конъюнкция гипотез, заданная списком гипотез, 
% то найти доказательство первой гипотезы Н1 из списка 
% с помощью найти1(H1,Стек,Дерево1), а затем найти доказательство оставшихся
% гипотез Т с помощью найти(T,Стек,Дерево) и
% объединить деревья вывода в общий список [Дерево1 | Дерево].
найти([],Стек,Дерево):-Дерево=[].
найти([H1|T],Стек,[Дерево1 | Дерево]):-
					найти1(H1,Стек,Дерево1),найти(T,Стек,Дерево).

% проверка: является ли гипотеза признаком, значение которого можно спросить
запрашиваемая(H):-Факт :: признак(H).

%=========вывод вопросов и обработка ответов "да, нет, почему" ==================
%вывод вопроса и ввод ответа
спроси(H,Стек):-write(H),write('?'),nl,
				read(O),ответ(H,O,Стек).
				
%обработка ответов: да, нет
ответ(H,да,Стек):-assert(сообщено(H,да)),!.
ответ(H,нет,Стек):-assert(сообщено(H,нет)),!,fail. 

%обработка ответов - "почему"
% случай1: стек целей пустой
ответ(H,почему,[]):-!,write(' Вы задаете слишком много вопросов'),nl, 
					спроси(H,[]).

%случай2: в стеке осталась только первая введенная цель, т.е доказываемая гипотеза
ответ(P,почему,[H]):-!,write('моя гипотеза: '),
					write(H),nl,спроси(P,[]).
					
%случай3: вывод заключения и номера правила для доказываемой текущей подцели Н
ответ(H,почему,[Правило | Стек]):-!,
			Правило :: если H1 то H2,
			write('пытаюсь доказать '),
			write(H2),nl,
			write('с помощью правила: '),
			write(Правило),nl,
			спроси(H,Стек).
			
%неправильный ответ: повторяем вопрос
ответ(H,_,Стек):-write(' правильный ответ: да, нет, почему'),nl,
		спроси(H,Стек).
		
%==============обработка ответов на вопросы "как?"=============================== 
% предикат как(H,Д)- выполняет поиск подцели Н в построенном 
% с помощью предиката "найти" дереве вывода Д и отображает соответствующий
% фрагмент дерева вывода, объясняя, как было получено доказательство Н.
% Дерево вывода Д представляет собой последовательность вложенных правил
% в виде списка, например:
% [правило5::если[правило1::если[сообщено(имеет(шерсть))]то млекопитающее,
%                        сообщено(ест_мясо)]то хищник,...]
%--------------------------------------------------------------------------------

% поиск целевого утверждения Н в дереве 
как(H,Дерево):-как1(H,Дерево),!.

% вывод сообщения, если Н не найдено
как(H,_):-write(H),tab(2),write('не доказано'),nl.

% случай1: если Н сообщено пользователем,
% то вывести "Н было введено"
как1(H,_):-сообщено(H,_),!, 
			write(H),write('было введено'),nl.

% случай2: если дерево вывода Д представлено фактом, подтверждающим Н
как1(H,Факт :: H):-!, 
		write(H), write( 'является фактом'), write(Факт),nl.
		
% случай3: если дерево вывода Д - правило в заключение, которого есть Н,
% то отобразить это правило
как1(H,[Правило :: если _ то H]):-!, 
		write(H),write(' было доказано с помощью'),nl,
		Правило :: если H1 то H,
		отобрази_правило(Правило :: если H1 то H).
	
% случай4: если в дереве Д нет правила с заключением Н,
%то поиск Н надо выполнять в дереве вывода предпосылок, т.е. в Дерево
как1(H,[Правило :: если Дерево то _]):-как(H,Дерево). 

% случай5: если дерево вывода - список поддеревьев вывода 
% каждой конъюнктивной подцели правила из БЗ, 
% то поиск Н следует выполнять в каждом из поддеревьев;
% поиск Н следует выполнять сначала в поддереве [Д1], а
% если Н не найдено, то продолжить поиск в оставшихся поддеревьях
как1(H,[]):-!.
как1(H,[Д1|Д2]):-как(H,[Д1]),!;
					как1(H,Д2).
					
%вывод правила на экран
отобрази_правило(Правило :: если H1 то H):-
		write(Правило), write( ':'),nl,
		write('если '), write(H1), nl,
		write('то '), write(H),nl.
		
/* Вызов интерпретатора*/
инициализация:-retractall(сообщено(_,_)).
start:-
		/* Загрузка базы знаний из файла*/
		reconsult('F:/base.pl'),
		info, %отображение информации о базе знаний*
		go_exp_sys. 
		
go_exp_sys:- инициализация,
			Факт :: гипотеза(H),
			найти([H],[H],Дерево), 
			write('решение:'),write(H),nl,
			объясни(Дерево),
			возврат.
			
%объяснение вывода утверждения
объясни(Дерево):-write( 'объяснить ? [цель/нет]:'), nl,read(H), 
				(H\=нет,!,как(H,Дерево),объясни(Дерево));!.
	
%поиск следующих решений
возврат:-write('Искать ещё решение [да/нет] ?: '),nl, read(нет).

%---------------------------------------------------------------------------
% База знаний ЭС
%---------------------------------------------------------------------------

info:-
	nl,
	write('*******************************'),nl,
	write('*      Экспертная система     *'),nl,
	write('*        Микропроцессоры      *'),nl,
	write('*                             *'),nl,
	write('*---------------------------- *'),nl,
	write('*    Отвечайте на вопросы:    *'),nl,
	write('*       да, нет, почему       *'),nl,
	write('*    Для объяснения решения   *'),nl,
	write('*         введите цель        *'),nl,
	write('*******************************'), nl ,
	write('Введите любой символ'),nl, %Ожидание ввода литеры
	get0(_).
	
% база продукционных правил классификации микропроцессоров
% предпосылки правил задаются в виде списка условий
% [условие1,условие2,...] означает - условие1 и условие2 и...
правило1 ::  если [вид(десктопный), разгонный_потенциал(большой)]
				то amd_Zen.
правило2 ::  если [вид(десктопный), разгонный_потенциал(небольшой), ядер(одно)]
				то intel8080.
правило3 ::  если [вид(десктопный), разгонный_потенциал(небольшой), ядер(два)]
				то intel_pentium.
правило4 ::  если [вид(десктопный), разгонный_потенциал(небольшой), ядер(четыре)]
				то intel_core_i7.
правило5 :: если [вид(мобильный), используется(nexus_4)]
			то quallcomm_snapdragon.
правило6 :: если [вид(мобильный), используется(iphone_6)]
			то apple_A9.
правило7 :: если [вид(мобильный), используется(lumia_920)]
			то qualcomm_MSM8960.
правило8 :: если [вид(мобильный), используется(asus_zenfone)]
			то intel_atom.
правило9 :: если [вид(мобильный), используется(samsung_galaxy_s6)]
			то samsung_Exynos_7420.
правило10 :: если [вид(мобильный), используется(raspberry_pi)]
				то arm.
% гипотезы 
h1 :: гипотеза(intel8080).
h2 :: гипотеза(intel_core_i7).
h3 :: гипотеза(arm). %raspberry_pi
h4 :: гипотеза(amd_Zen).
h5 :: гипотеза(quallcomm_snapdragon). %nexus 4
h6 :: гипотеза(intel_pentium).
h7 :: гипотеза(intel_atom).
h8 :: гипотеза(qualcomm_MSM8960). %lumia 920
h9 :: гипотеза(apple_A9). %iphone 6
h10 :: гипотеза(samsung_Exynos_7420).

% признаки микропроцессоров, истинность которых можно выяснить у пользователя
q1 :: признак(вид(мобильный)).
q2 :: признак(вид(десктопный)).
q3 :: признак(разгонный_потенциал(большой)).
q4 :: признак(разгонный_потенциал(небольшой)).
q5 :: признак(используется(nexus_4)).
q6 :: признак(используется(iphone_6)).
q7 :: признак(используется(lumia_920)).
q8 :: признак(используется(asus_zenfone)).
q9 :: признак(используется(samsung_galaxy_s6)).
q10 :: признак(ядер(два)).
q11 :: признак(ядер(четыре)).
q12 :: признак(ядер(одно)).
q13 :: признак(используется(raspberry_pi)).	
\end{lstlisting}

\subsection{Проверка работы программы}
\begin{lstlisting}
вид(десктопный)?
|да.
разгонный_потенциал(небольшой)?
:-нет.
вид(мобильный)?
:-нет.
разгонный_потенциал(большой)?
:-да.
решение:amd_Zen
объяснить ? [цель/нет]:
:-нет.
Искать ещё решение [да/нет] ?: 
:-да.
false.


:-
вид(десктопный)?
|да.
разгонный_потенциал(небольшой)?
:-да.
ядер(одно)?
:-почему.
пытаюсь доказать intel8080
с помощью правила: правило2
ядер(одно)?
:-нет.
ядер(четыре)?
:-нет.
вид(мобильный)?
:-нет.
разгонный_потенциал(большой)?
:-нет.
ядер(два)?
:-да.
решение:intel_pentium
объяснить ? [цель/нет]:
\end{lstlisting}

\section*{Выводы}
В ходе выполнения лабораторной работы была разработана экспертная система
продукционного типа на Прологе, а также исследованы базовые принципы организации
экспертных систем.
\end{document}